Easy

1. Using unordered hashTable for storing address
2. Floydâ€™s Cycle-Finding Algorithm // fast slow approach // 2 pointers // "tortoise and the hare algorithm"

Apporach 1:
bool cycleDetect(node* head) {
    unordered_set<node*> hashTable;
    while(head != NULL) {
        if(hashTable.find(head) != hashTable.end()) return true;
        hashTable.insert(head);
        head = head->next;
    }
    return false;
}

TC: O(N)
SC: O(N)

Approach 2:
Logic: fast never get's NULL if loop exist.
if slow & fast meet then loop exist. otherwise fast reaches NULL.

bool hasCycle(ListNode *head) {
    ListNode *fast = head;
    ListNode *slow = head;

    while(fast != NULL && fast->next != NULL) {
        fast = fast->next->next; //2 steps
        slow = slow->next; //1 steps
        if(fast == slow) return true;
    }
    return false;
}

TC: O(N)
SC: O(1)
